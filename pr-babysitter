#!/bin/bash

set -euo pipefail

# GitHub API constants
readonly GITHUB_API_VERSION="2022-11-28"
readonly GITHUB_ACCEPT_HEADER="application/vnd.github+json"
readonly DEFAULT_WAIT_TIME=300  # 5 minutes

# Source configuration file if it exists
# Configuration file can set GITHUB_TOKEN for authentication
if [ -r "${HOME}/.pr-babysitter" ]; then
    # shellcheck source=/dev/null
    . "${HOME}/.pr-babysitter"
elif [ -r "${HOME}/.config/pr-babysitter" ]; then
    # shellcheck source=/dev/null
    . "${HOME}/.config/pr-babysitter"
fi

# Warn if neither GITHUB_TOKEN nor GH_TOKEN is set
if [ -z "${GITHUB_TOKEN:-}" ] && [ -z "${GH_TOKEN:-}" ]; then
    echo -e "\033[1m‚ö†Ô∏è  WARNING: Neither GITHUB_TOKEN nor GH_TOKEN is set. Check reruns might not work.\033[0m" >&2
    sleep 3
fi

# Usage function
usage() {
    echo "Usage: pr-babysitter [OPTIONS] <PR_NUMBER> [REPO]"
    echo "       pr-babysitter [OPTIONS] -c CHECK_ID [REPO]"
    echo "       pr-babysitter [OPTIONS] -W WORKFLOW_ID [REPO]"
    echo ""
    echo "Monitor the status of checks for a GitHub PR, or directly re-run checks/workflows"
    echo ""
    echo "Desktop notifications will be sent when checks fail (if available)."
    echo ""
    echo "Configuration:"
    echo "  The script will source configuration from the first file found:"
    echo "    - \${HOME}/.pr-babysitter"
    echo "    - \${HOME}/.config/pr-babysitter"
    echo ""
    echo "  Authentication:"
    echo "    Either GH_TOKEN or GITHUB_TOKEN environment variables must be"
    echo "    defined for individual check re-runs to work properly. Without"
    echo "    proper authentication, re-run operations may fail. The variables"
    echo "    can be set in the configuration file."
    echo ""
    echo "Options:"
    echo "  -f            Only show failed checks, do not monitor"
    echo "  -w SECONDS    Wait time in seconds between checks (default: 300)"
    echo "  -r MODE       Re-run mode for failed checks:"
    echo "                  ask         - Prompt for re-run option (default)"
    echo "                  check       - Re-run individual check runs"
    echo "                  workflow    - Re-run entire workflow runs"
    echo "                  failed-jobs - Re-run only failed jobs in workflows"
    echo "                  label:NAME  - Add specified label NAME to the PR"
    echo "  -c CHECK_ID   Directly re-run a specific check run by ID"
    echo "  -W WORKFLOW_ID Directly re-run a specific workflow run by ID"
    echo "  -v            Enable verbose mode"
    echo "  -h            Show this help message"
    echo ""
    echo "Arguments:"
    echo "  PR_NUMBER  The pull request number to monitor"
    echo "  REPO       Optional repository in owner/repo format (defaults to current repo)"
    echo ""
    echo "Examples:"
    echo "  # PR Monitoring"
    echo "  pr-babysitter 123                          # Monitor PR #123 in current repo"
    echo "  pr-babysitter 123 owner/repo               # Monitor PR #123 in specified repo"
    echo "  pr-babysitter -f 123                       # Show only failed checks"
    echo "  pr-babysitter -w 300 123                   # Monitor with 5 minute interval"
    echo "  pr-babysitter -r workflow 123              # Auto re-run entire workflows"
    echo "  pr-babysitter -r failed-jobs -f 123        # Re-run failed jobs, show failed only"
    echo "  pr-babysitter -r label:re-run 123          # Add 're-run' label to PR #12"
    echo ""
    echo "  # Direct Re-run"
    echo "  pr-babysitter -c 61523939520 owner/repo    # Re-run specific check run"
    echo "  pr-babysitter -W 21373540416 owner/repo    # Re-run specific workflow run"
    exit 0
}

gh_api_get() {
    local endpoint="${1}"
    shift

    gh api \
        -H "Accept: ${GITHUB_ACCEPT_HEADER}" \
        -H "X-GitHub-Api-Version: ${GITHUB_API_VERSION}" \
        "${endpoint}" \
        "$@"
}

gh_api_post() {
    local endpoint="${1}"
    shift
    local token="${GITHUB_TOKEN:-${GH_TOKEN}}"

    gh api \
        --method POST \
        -H "Accept: ${GITHUB_ACCEPT_HEADER}" \
        -H "X-GitHub-Api-Version: ${GITHUB_API_VERSION}" \
        ${token:+-H "Authorization: Bearer ${token}"} \
        "${endpoint}" \
        "$@"
}

get_pr_head_sha() {
    local pr_number="${1}"
    local repo="${2}"
    gh pr view "${pr_number}" ${repo:+--repo "${repo}"} --json headRefOid -q '.headRefOid'
}

get_pr_title() {
    local pr_number="${1}"
    local repo="${2}"
    gh pr view "${pr_number}" ${repo:+--repo "${repo}"} --json title -q '.title'
}

get_check_runs() {
    local repo="${1}"
    local ref="${2}"

    gh_api_get "/repos/${repo}/commits/${ref}/check-runs" | \
    jq '[.check_runs[] | {
        id: .id,
        name: .name,
        state: (
            if .status == "queued" then "QUEUED"
            elif .status == "in_progress" then "IN_PROGRESS"
            elif .status == "completed" and .conclusion == "success" then "SUCCESS"
            elif .status == "completed" and .conclusion == "failure" then "FAILURE"
            elif .status == "completed" and .conclusion == "cancelled" then "CANCELED"
            else "UNKNOWN"
            end
        ),
        link: .html_url,
        completedAt: .completed_at,
        checkSuiteId: .check_suite.id,
        appName: (.app.name // ""),
        isGitHubActions: (.app.slug == "github-actions")
    }]'
}

quiet() {
    local err=0
    if [[ "${VERBOSE:-}" = "YES" ]]; then
        printf "\033[30;1m"
        "$@"
        err=$?
        printf "\033[0m"
    else
        "$@" >/dev/null 2>&1
        err=$?
    fi
    return "${err}"
}

rerun_check() {
    local repo="${1}"
    local check_run_id="${2}"

    quiet gh_api_post "/repos/${repo}/check-runs/${check_run_id}/rerequest"
}

get_check_run_details() {
    local repo="${1}"
    local check_run_id="${2}"

    gh_api_get "/repos/${repo}/check-runs/${check_run_id}" 2>/dev/null || return 1
}

get_workflow_run_id_from_check() {
    local repo="${1}"
    local check_run_id="${2}"

    # Get check run details and extract workflow run URL
    local details
    details=$(get_check_run_details "${repo}" "${check_run_id}") || return 1

    # Extract run_id from html_url (format: .../actions/runs/{run_id}/...)
    jq -r '.html_url' <<<"${details}" | grep -oP 'runs/\K[0-9]+' | head -1 || return 1
}

rerun_workflow_run() {
    local repo="${1}"
    local run_id="${2}"

    if ! quiet gh_api_post "/repos/${repo}/actions/runs/${run_id}/rerun"; then
        echo "    Warning: Failed to re-run workflow ${run_id}" >&2
        return 1
    fi

    return 0
}

rerun_failed_jobs() {
    local repo="${1}"
    local run_id="${2}"

    if ! quiet gh_api_post "/repos/${repo}/actions/runs/${run_id}/rerun-failed-jobs"; then
        echo "    Warning: Failed to re-run failed jobs in workflow ${run_id}" >&2
        return 1
    fi

    return 0
}

render_checks() {
    # '.[] | select(.state != "SUCCESS" and .state != "IN_PROGRESS" and .state != "QUEUED") |
    FILTER="${1:-"true"}"
    cat - | \
    jq -r \
    ".[] | select(${FILTER}) |
        (if .state == \"SUCCESS\" then \"‚úÖ\"
         elif .state == \"IN_PROGRESS\" then \"üîµ\"
         elif .state == \"QUEUED\" then \"üßµ\"
         elif .state == \"FAILURE\" then \"üö®\"
         elif .state == \"CANCELED\" then \"‚úñÔ∏è\"
         else \"‚ùì\" end) as \$emoji |
        \"\\(\$emoji) \\(.name)\\n\\(.link)\""
}

add_pr_label() {
    local repo="${1}"
    local pr_number="${2}"
    local label="${3}"

    if ! gh --repo "${repo}" pr edit "${pr_number}" --add-label "${label}"
    then
        echo "    Warning: Failed to add label '${label}' to PR #${pr_number}" >&2
        return 1
    fi

    return 0
}

send_desktop_notification() {
    local failed_count="${1}"
    local pr_title="${2}"

    # Check if notify-send is available
    if ! quiet command -v notify-send; then
        return 0
    fi

    # Determine urgency based on failure count
    local urgency="normal"
    if [ "${failed_count}" -gt 5 ]; then
        urgency="critical"
    fi

    # Send notification
    notify-send \
        --urgency="${urgency}" \
        --app-name="pr-babysitter" \
        --icon="dialog-error" \
        "PR Check Failures" \
        "${failed_count} check(s) failed for:\n${pr_title}"
}

send_success_notification() {
    local pr_title="${1}"

    # Check if notify-send is available
    if ! quiet command -v notify-send; then
        return 0
    fi

    # Send notification
    notify-send \
        --urgency="normal" \
        --app-name="pr-babysitter" \
        --icon="dialog-information" \
        "PR Checks Passed" \
        "All checks passed successfully for:\n${pr_title}"
}

rerun_github_action() {
    # Determine re-run mode
    rerun_action="${RERUN_MODE}"
    if [ "${RERUN_MODE}" = "ask" ]; then
        echo ""
        echo "Re-run options:"
        echo "  1) Re-run individual check runs (default)"
        echo "  2) Re-run entire workflow runs (all jobs)"
        echo "  3) Re-run only failed jobs in workflows"
        echo "  4) Add a label to re-run checks"
        echo "  n) Skip re-run"
        echo ""
        read -p "Select option (1-3, n): " -n 1 -r
        echo ""

        case ${REPLY} in
            1|"")
                rerun_action="check"
                ;;
            2)
                rerun_action="workflow"
                ;;
            3)
                rerun_action="failed-jobs"
                ;;
            4)
                rerun_action="label"
                ;;
            [Nn])
                rerun_action="skip"
                ;;
            *)
                echo "Invalid option. Skipping re-run."
                rerun_action="skip"
                ;;
        esac
    fi

    # Execute the selected re-run action
    case ${rerun_action} in
        check)
            echo ""
            echo "Re-running individual check runs..."
            # Get all failed checks with their IDs and names
            jq -r "[.[] | select(${FAILED_CHECK_FILTER})] | .[] | \"\(.id)|\(.name)\"" <<<"${CHECKS_JSON}" | \
            while IFS='|' read -r check_id check_name; do
                echo "  Requesting re-run for: ${check_name}"
                rerun_check "${REPO}" "${check_id}" || true
            done
            ;;
        workflow)
            echo ""
            echo "Re-running entire workflow runs..."
            # Get unique workflow run IDs from failed GitHub Actions checks
            FAILED_GA_CHECKS=$(jq -r "[.[] | select(${FAILED_CHECK_FILTER}) | select(.isGitHubActions == true)] | unique_by(.checkSuiteId)" <<<"${CHECKS_JSON}")

            # shellcheck disable=SC2312
            if [ "$(jq 'length' <<<"${FAILED_GA_CHECKS}")" -eq 0 ]; then
                echo "  No GitHub Actions workflows to re-run"
            else
                # shellcheck disable=SC2034
                jq -r '.[] | "\(.id)|\(.name)|\(.appName)"' <<<"${FAILED_GA_CHECKS}" | \
                while IFS='|' read -r check_id check_name app_name; do
                    echo "  Finding workflow run for: ${check_name}"
                    run_id=$(get_workflow_run_id_from_check "${REPO}" "${check_id}")

                    if [ -n "${run_id}" ]; then
                        echo "    Re-running workflow run ${run_id}..."
                        rerun_workflow_run "${REPO}" "${run_id}" || true
                    else
                        echo "    Warning: Could not find workflow run ID"
                    fi
                done
            fi
            ;;
        failed-jobs)
            echo ""
            echo "Re-running only failed jobs in workflows..."
            # Get unique workflow run IDs from failed GitHub Actions checks
            FAILED_GA_CHECKS=$(jq -r "[.[] | select(${FAILED_CHECK_FILTER}) | select(.isGitHubActions == true)] | unique_by(.checkSuiteId)" <<<"${CHECKS_JSON}")

            # shellcheck disable=SC2312
            if [ "$(jq 'length' <<<"${FAILED_GA_CHECKS}")" -eq 0 ]; then
                echo "  No GitHub Actions workflows to re-run"
            else
                # shellcheck disable=SC2034
                jq -r '.[] | "\(.id)|\(.name)|\(.appName)"' <<<"${FAILED_GA_CHECKS}" | \
                while IFS='|' read -r check_id check_name app_name; do
                    echo "  Finding workflow run for: ${check_name}"
                    run_id=$(get_workflow_run_id_from_check "${REPO}" "${check_id}")

                    if [ -n "${run_id}" ]; then
                        echo "    Re-running failed jobs in workflow run ${run_id}..."
                        rerun_failed_jobs "${REPO}" "${run_id}" || true
                    else
                        echo "    Warning: Could not find workflow run ID"
                    fi
                done
            fi
            ;;
        label)
            echo ""
            IFS= read -p "Label name: " -r LABEL_NAME
            echo "Adding label '${LABEL_NAME}' to PR #${PR_NUMBER}..."
            if add_pr_label "${REPO}" "${PR_NUMBER}" "${LABEL_NAME}"; then
                echo "  Successfully added label '${LABEL_NAME}'"
            else
                echo "  Failed to add label"
            fi
            ;;
        skip)
            echo "Skipping re-run."
            return 0
            ;;
        *)
            echo "Unknown re-run mode: ${rerun_action}. Skipping."
            return 1
            ;;
    esac

    echo "Done."
}

# Check if gh is installed
if ! quiet command -v gh; then
    echo "Error: gh CLI is not installed. Please install it from https://cli.github.com/"
    exit 1
fi

# Check if jq is installed
if ! quiet command -v jq; then
    echo "Error: jq is not installed."
    exit 1
fi

# Verify gh authentication
if ! quiet gh auth status; then
    echo "Error: gh is not authenticated. Run 'gh auth login' first."
    exit 1
fi

# Default values
WAIT_TIME="${DEFAULT_WAIT_TIME}"
FAILED_ONLY=false
RERUN_MODE="ask"  # ask, check, workflow, failed-jobs, label
LABEL_NAME=""     # Label name to add to PR when using label mode
CHECK_ID=""       # Direct check run ID to re-run
WORKFLOW_ID=""    # Direct workflow run ID to re-run

# Parse options
while getopts "fw:r:c:W:vh" opt; do
    case ${opt} in
        f)
            FAILED_ONLY=true
            ;;
        w)
            WAIT_TIME="${OPTARG}"
            ;;
        r)
            # Validate rerun mode
            case "${OPTARG}" in
                check|workflow|failed-jobs|ask)
                    RERUN_MODE="${OPTARG}"
                    ;;
                label:*)
                    RERUN_MODE="label"
                    LABEL_NAME="${OPTARG#label:}"
                    if [[ -z "${LABEL_NAME}" ]]
                    then
                        echo "Error: Label name must not be empty."
                        exit 1
                    fi
                    ;;
                *)
                    echo "Error: Invalid rerun mode. Use: check, workflow, failed-jobs, label:NAME, or ask"
                    exit 1
                    ;;
            esac
            ;;
        c)
            # Validate check run ID is numeric
            if ! [[ "${OPTARG}" =~ ^[0-9]+$ ]]; then
                echo "Error: CHECK_ID must be a positive integer"
                exit 1
            fi
            CHECK_ID="${OPTARG}"
            ;;
        W)
            # Validate workflow run ID is numeric
            if ! [[ "${OPTARG}" =~ ^[0-9]+$ ]]; then
                echo "Error: WORKFLOW_ID must be a positive integer"
                exit 1
            fi
            WORKFLOW_ID="${OPTARG}"
            ;;
        v)
            VERBOSE="YES"
            ;;
        h)
            usage
            ;;
        *)
            echo "Error: invalid option: ${opt}"
            exit 1
            ;;
    esac
done
shift $((OPTIND - 1))

# Parse arguments based on mode
if [ -n "${CHECK_ID}" ] || [ -n "${WORKFLOW_ID}" ]; then
    # Direct re-run mode: only REPO is required
    REPO="${1:-}"
    PR_NUMBER=""

    if [ -z "${REPO}" ]; then
        # Try to get repo from git
        REPO=$(gh repo view --json nameWithOwner -q '.nameWithOwner' 2>/dev/null || echo "")
        if [ -z "${REPO}" ]; then
            echo "Error: REPO required for direct re-run. Specify as argument or run from git repository."
            exit 1
        fi
    fi
elif [ "${RERUN_MODE}" == "label" ]; then
    PR_NUMBER="${1}"
    REPO="${2:-}"
    if [ -z "${REPO}" ]; then
        # Try to get repo from git
        REPO=$(gh repo view --json nameWithOwner -q '.nameWithOwner' 2>/dev/null || echo "")
        if [ -z "${REPO}" ]; then
            echo "Error: REPO required for direct re-run. Specify as argument or run from git repository."
            exit 1
        fi
    fi
else
    # Normal PR monitoring mode
    PR_NUMBER="${1}"
    REPO="${2:-}"

    if [ -z "${PR_NUMBER}" ]; then
        usage
    fi

    # Validate PR_NUMBER is numeric
    if ! [[ "${PR_NUMBER}" =~ ^[0-9]+$ ]]; then
        echo "Error: PR_NUMBER must be a positive integer"
        exit 1
    fi

    # If REPO is not provided, try to get it from the current git repository
    if [ -z "${REPO}" ]; then
        REPO=$(gh repo view --json nameWithOwner -q '.nameWithOwner' 2>/dev/null || echo "")
        if [ -z "${REPO}" ]; then
            echo "Error: Could not determine repository. Please specify REPO argument or run from within a git repository."
            exit 1
        fi
    fi
fi

# Validate REPO format (owner/repo)
if ! [[ "${REPO}" =~ ^[a-zA-Z0-9_.-]+/[a-zA-Z0-9_.-]+$ ]]; then
    echo "Error: REPO must be in owner/repo format"
    exit 1
fi

# Handle direct re-run mode
if [ -n "${CHECK_ID}" ]; then
    echo "Re-running check run ${CHECK_ID} in ${REPO}..."
    if rerun_check "${REPO}" "${CHECK_ID}"; then
        echo "‚úÖ Successfully requested re-run for check ${CHECK_ID}"
    else
        echo "‚ùå Failed to re-run check ${CHECK_ID}"
        exit 1
    fi
    exit 0
elif [ -n "${WORKFLOW_ID}" ]; then
    echo "Re-running workflow run ${WORKFLOW_ID} in ${REPO}..."
    if rerun_workflow_run "${REPO}" "${WORKFLOW_ID}"; then
        echo "‚úÖ Successfully requested re-run for workflow ${WORKFLOW_ID}"
    else
        echo "‚ùå Failed to re-run workflow ${WORKFLOW_ID}"
        exit 1
    fi
    exit 0
elif [ "${RERUN_MODE}" == "label" ]; then
    echo "Re-runing checks by adding label '${LABEL_NAME}' to '${REPO}'..."
    if add_pr_label "${REPO}" "${PR_NUMBER}" "${LABEL_NAME}"; then
        echo "‚úÖ Successfully add label to ${REPO}"
    else
        echo "‚ùå Failed to add label to ${REPO}"
        exit 1
    fi
    exit 0
fi

# Get the latest commit SHA for the PR
PR_HEAD_SHA=$(get_pr_head_sha "${PR_NUMBER}" "${REPO}")
if [ -z "${PR_HEAD_SHA}" ]; then
    echo "Error: Could not get HEAD SHA for PR #${PR_NUMBER}"
    exit 1
fi

# Get the PR title for notifications
PR_TITLE=$(get_pr_title "${PR_NUMBER}" "${REPO}")
if [ -z "${PR_TITLE}" ]; then
    PR_TITLE="PR #${PR_NUMBER}"
fi

# ANSI color codes
# shellcheck disable=SC2034
WHITE="\033[1;37m"
# shellcheck disable=SC2034
CYAN="\033[36m"
# shellcheck disable=SC2034
RESET="\033[0m"

# If failed-only mode, show failed checks and exit
if [ "${FAILED_ONLY}" = true ]; then
    CHECKS_JSON=$(get_check_runs "${REPO}" "${PR_HEAD_SHA}")
    FAILED_CHECKS=$(jq '[.[] | select(.state != "SUCCESS" and .state != "IN_PROGRESS" and .state != "QUEUED")] | length' <<<"${CHECKS_JSON}")

    if [ "${FAILED_CHECKS}" -eq 0 ]; then
        echo "No failed checks found for PR #${PR_NUMBER}"
        exit 0
    fi

    echo "==================================="
    echo "Failed Checks for PR #${PR_NUMBER}"
    echo "==================================="
    echo ""
    render_checks '.state != "SUCCESS" and .state != "IN_PROGRESS" and .state != "QUEUED"' <<<"${CHECKS_JSON}"
    send_desktop_notification "${FAILED_CHECKS}" "${PR_TITLE}"
    exit 0
fi

# Monitor checks
echo "Monitoring checks for PR #${PR_NUMBER}..."
echo ""

# Common filters
FAILED_CHECK_FILTER=".state != \"SUCCESS\" and .state != \"IN_PROGRESS\" and .state != \"QUEUED\""
RUNNING_CHECK_FILTER=".state == \"IN_PROGRESS\" or .state == \"QUEUED\""

# Track previous failure count to avoid notification spam
PREV_FAILED_CHECKS=0

while true; do
    # Clear screen for clean output
    clear

    echo "==================================="
    echo "PR #${PR_NUMBER} - Check Status"
    echo "==================================="
    echo ""

    # Get latest commit SHA (in case there are new commits)
    PR_HEAD_SHA=$(get_pr_head_sha "${PR_NUMBER}" "${REPO}")

    # Get check status
    CHECKS_JSON=$(get_check_runs "${REPO}" "${PR_HEAD_SHA}")

    # Format and display output
    render_checks <<<"${CHECKS_JSON}"

    echo ""
    echo "-----------------------------------"
    # shellcheck disable=SC2312
    echo "Last updated: $(date '+%Y-%m-%d %H:%M:%S')"

    # Check for failed checks and send notification if count changed
    FAILED_CHECKS=$(jq "[.[] | select(${FAILED_CHECK_FILTER})] | length" <<<"${CHECKS_JSON}")
    if [ "${FAILED_CHECKS}" -gt 0 ] && [ "${FAILED_CHECKS}" -ne "${PREV_FAILED_CHECKS}" ]; then
        send_desktop_notification "${FAILED_CHECKS}" "${PR_TITLE}"
        PREV_FAILED_CHECKS="${FAILED_CHECKS}"
    fi

    # Check if there are any IN_PROGRESS or QUEUED checks
    ACTIVE_CHECKS=$(jq "[.[] | select(${RUNNING_CHECK_FILTER})] | length" <<<"${CHECKS_JSON}")

    if [ "${ACTIVE_CHECKS}" -eq 0 ]; then
        echo "All checks completed. Monitoring stopped."
        echo "-----------------------------------"

        if [ "${FAILED_CHECKS}" -gt 0 ]; then
            echo ""
            echo "There are ${FAILED_CHECKS} failed check(s)."
            rerun_github_action
        else
            echo ""
            echo "‚úÖ All checks passed successfully!"
            send_success_notification "${PR_TITLE}"
            # Exit monitoring loop
            break
        fi
    fi

    echo "Press Ctrl+C to stop monitoring"
    echo "-----------------------------------"

    # Wait before next check
    sleep "${WAIT_TIME}"
done
