#!/bin/bash

set -euo pipefail

# Version
readonly VERSION="1.0.2"

# GitHub API constants
readonly GITHUB_API_VERSION="2022-11-28"
readonly GITHUB_ACCEPT_HEADER="application/vnd.github+json"
readonly DEFAULT_WAIT_TIME=300  # 5 minutes

# Source configuration file if it exists
# Configuration file can set GITHUB_TOKEN for authentication
if [ -r "${HOME}/.pr-babysitter" ]; then
    # shellcheck source=/dev/null
    . "${HOME}/.pr-babysitter"
elif [ -r "${HOME}/.config/pr-babysitter" ]; then
    # shellcheck source=/dev/null
    . "${HOME}/.config/pr-babysitter"
fi

# Note: Token warning will be shown later if using GitHub service

# Usage function
usage() {
    echo "Usage: pr-babysitter [OPTIONS] <PR_NUMBER> [REPO]"
    echo "       pr-babysitter [OPTIONS] -c CHECK_ID [REPO]"
    echo "       pr-babysitter [OPTIONS] -W WORKFLOW_ID [REPO]"
    echo "       pr-babysitter [OPTIONS] -m REPO <PR_NUMBER> [PR_NUMBER...]"
    echo ""
    echo "Monitor the status of checks for a GitHub PR, or directly re-run checks/workflows"
    echo ""
    echo "Options:"
    echo "  -f            Only show failed checks, do not monitor"
    echo "  -w SECONDS    Wait time in seconds between checks (default: 300)"
    echo "  -s SERVICE    Remote service (default: github)"
    echo "                  github              - GitHub (github.com)"
    echo "                  codeberg            - Codeberg (codeberg.org)"
    echo "                  https://HOST        - Custom service URL"
    echo "  -r MODE       Re-run mode for failed checks:"
    echo "                  ask         - Prompt for re-run option (default)"
    echo "                  check       - Re-run individual check runs"
    echo "                  workflow    - Re-run entire workflow runs"
    echo "                  failed-jobs - Re-run only failed jobs in workflows"
    echo "                  label:NAME  - Add specified label NAME to the PR"
    echo "  -c CHECK_ID   Directly re-run a specific check run by ID"
    echo "  -W WORKFLOW_ID Directly re-run a specific workflow run by ID"
    echo "  -m REPO       Monitor multiple PRs for the specified repository"
    echo "  -v            Enable verbose mode"
    echo "  -V            Show version and exit"
    echo "  -h            Show this help message"
    echo ""
    echo "Arguments:"
    echo "  PR_NUMBER  The pull request number to monitor"
    echo "  REPO       Optional repository in owner/repo format (defaults to current repo)"
    exit 0
}

get_hostname() {
    local service="${SERVICE:-github}"

    case "${service}" in
        github)
            echo "github.com"
            ;;
        codeberg)
            echo "codeberg.org"
            ;;
        https://*)
            # Extract hostname from URL
            echo "${service#https://}" | cut -d/ -f1
            ;;
        http://*)
            # Extract hostname from URL
            echo "${service#http://}" | cut -d/ -f1
            ;;
        *)
            # Assume it's a hostname
            echo "${service}"
            ;;
    esac
}

get_api_url() {
    local service="${SERVICE:-github}"
    local hostname
    hostname=$(get_hostname)

    case "${service}" in
        github)
            echo "https://api.github.com"
            ;;
        codeberg)
            # Codeberg uses Forgejo/Gitea API
            echo "https://${hostname}/api/v1"
            ;;
        https://*|http://*)
            # Custom instance - try Gitea/Forgejo API first
            # GitHub Enterprise would use /api/v3
            echo "${service%/}/api/v1"
            ;;
        *)
            # Default to Gitea/Forgejo API for custom hostnames
            echo "https://${hostname}/api/v1"
            ;;
    esac
}

get_pr_url() {
    local repo="${1}"
    local pr_number="${2}"
    local hostname
    local service="${SERVICE:-github}"
    hostname=$(get_hostname)

    # GitHub uses /pull/ (singular), Gitea/Forgejo use /pulls/ (plural)
    case "${service}" in
        github)
            echo "https://${hostname}/${repo}/pull/${pr_number}"
            ;;
        *)
            echo "https://${hostname}/${repo}/pulls/${pr_number}"
            ;;
    esac
}

get_api_token() {
    echo "${GITHUB_TOKEN:-${GH_TOKEN}}"
}

get_repo_from_git() {
    # Try to extract repository from git remote URL
    local remote_url
    remote_url=$(git remote get-url origin 2>/dev/null || echo "")

    if [ -z "${remote_url}" ]; then
        return 1
    fi

    # Extract owner/repo from various URL formats:
    # - https://host.com/owner/repo.git
    # - git@host.com:owner/repo.git
    # - https://host.com/owner/repo
    if [[ "${remote_url}" =~ [:/]([^/]+/[^/]+)(\.git)?$ ]]; then
        local repo="${BASH_REMATCH[1]}"
        echo "${repo%.git}"
        return 0
    fi

    return 1
}

gh_api_get() {
    local endpoint="${1}"
    shift
    local api_url
    local service="${SERVICE:-github}"
    api_url=$(get_api_url)

    # Only GitHub requires authentication token
    case "${service}" in
        github)
            local token
            token=$(get_api_token)

            if [ -z "${token}" ]; then
                echo "Error: GITHUB_TOKEN or GH_TOKEN environment variable required" >&2
                return 1
            fi

            curl -s -H "Accept: ${GITHUB_ACCEPT_HEADER}" \
                -H "X-GitHub-Api-Version: ${GITHUB_API_VERSION}" \
                -H "Authorization: Bearer ${token}" \
                "${api_url}${endpoint}" \
                "$@"
            ;;
        *)
            # Gitea/Forgejo - no authentication
            curl -s "${api_url}${endpoint}" "$@"
            ;;
    esac
}

gh_api_post() {
    local endpoint="${1}"
    shift
    local api_url
    local service="${SERVICE:-github}"
    api_url=$(get_api_url)

    # Only GitHub requires authentication token
    case "${service}" in
        github)
            local token
            token=$(get_api_token)

            if [ -z "${token}" ]; then
                echo "Error: GITHUB_TOKEN or GH_TOKEN environment variable required" >&2
                return 1
            fi

            curl -s -X POST \
                -H "Accept: ${GITHUB_ACCEPT_HEADER}" \
                -H "X-GitHub-Api-Version: ${GITHUB_API_VERSION}" \
                -H "Authorization: Bearer ${token}" \
                "${api_url}${endpoint}" \
                "$@"
            ;;
        *)
            # Gitea/Forgejo - no authentication
            curl -s -X POST "${api_url}${endpoint}" "$@"
            ;;
    esac
}

get_pr_head_sha() {
    local pr_number="${1}"
    local repo="${2}"
    gh_api_get "/repos/${repo}/pulls/${pr_number}" | jq -r '.head.sha'
}

get_pr_title() {
    local pr_number="${1}"
    local repo="${2}"
    gh_api_get "/repos/${repo}/pulls/${pr_number}" | jq -r '.title'
}

get_pr_labels() {
    local pr_number="${1}"
    local repo="${2}"
    gh_api_get "/repos/${repo}/pulls/${pr_number}" | jq -r '[.labels[].name] | join(", ")'
}

get_check_runs() {
    local repo="${1}"
    local ref="${2}"
    local service="${SERVICE:-github}"

    case "${service}" in
        github)
            # GitHub check-runs API
            gh_api_get "/repos/${repo}/commits/${ref}/check-runs" | \
            jq '[.check_runs[] | {
                id: .id,
                name: .name,
                state: (
                    if .status == "queued" then "QUEUED"
                    elif .status == "in_progress" then "IN_PROGRESS"
                    elif .status == "completed" and .conclusion == "success" then "SUCCESS"
                    elif .status == "completed" and .conclusion == "failure" then "FAILURE"
                    elif .status == "completed" and .conclusion == "cancelled" then "CANCELED"
                    else "UNKNOWN"
                    end
                ),
                link: .html_url,
                completedAt: .completed_at,
                checkSuiteId: .check_suite.id,
                appName: (.app.name // ""),
                isGitHubActions: (.app.slug == "github-actions")
            }]'
            ;;
        *)
            # Gitea/Forgejo commit statuses API
            #
            gh_api_get "/repos/${repo}/commits/${ref}/status" | \
            jq '[.statuses[]? | {
                name: .context,
                state: (
                    if .status == "pending" then "IN_PROGRESS"
                    elif .status == "success" then "SUCCESS"
                    elif .status == "failure" or .state == "error" then "FAILURE"
                    else "UNKNOWN"
                    end
                ),
                link: .target_url,
                completedAt: .updated_at,
                checkSuiteId: .id,
                appName: (.creator.login // "Forgejo"),
                isGitHubActions: false
            }]'
            ;;
    esac
}

quiet() {
    local err=0
    if [[ "${VERBOSE:-}" = "YES" ]]; then
        printf "\033[30;1m"
        "$@"
        err=$?
        printf "\033[0m"
    else
        "$@" >/dev/null 2>&1
        err=$?
    fi
    return "${err}"
}

rerun_check() {
    local repo="${1}"
    local check_run_id="${2}"

    quiet gh_api_post "/repos/${repo}/check-runs/${check_run_id}/rerequest"
}

get_check_run_details() {
    local repo="${1}"
    local check_run_id="${2}"

    gh_api_get "/repos/${repo}/check-runs/${check_run_id}" 2>/dev/null || return 1
}

get_workflow_run_id_from_check() {
    local repo="${1}"
    local check_run_id="${2}"

    # Get check run details and extract workflow run URL
    local details
    details=$(get_check_run_details "${repo}" "${check_run_id}") || return 1

    # Extract run_id from html_url (format: .../actions/runs/{run_id}/...)
    jq -r '.html_url' <<<"${details}" | grep -oP 'runs/\K[0-9]+' | head -1 || return 1
}

rerun_workflow_run() {
    local repo="${1}"
    local run_id="${2}"

    if ! quiet gh_api_post "/repos/${repo}/actions/runs/${run_id}/rerun"; then
        echo "    Warning: Failed to re-run workflow ${run_id}" >&2
        return 1
    fi

    return 0
}

rerun_failed_jobs() {
    local repo="${1}"
    local run_id="${2}"

    if ! quiet gh_api_post "/repos/${repo}/actions/runs/${run_id}/rerun-failed-jobs"; then
        echo "    Warning: Failed to re-run failed jobs in workflow ${run_id}" >&2
        return 1
    fi

    return 0
}

render_checks() {
    FILTER="${1:-"true"}"
    # Note that the sorting is done so that SUCCESS is the last item.
    cat - | \
    jq -r \
    "[.[] | select(${FILTER})] |
    sort_by(
        if .state == \"FAILURE\" then 1
        elif .state == \"CANCELED\" then 2
        elif .state == \"IN_PROGRESS\" then 3
        elif .state == \"QUEUED\" then 4
        elif .state == \"SUCCESS\" then 6
        else 5 end
    ) | .[] |
        (if .state == \"SUCCESS\" then \"‚úÖ\"
         elif .state == \"IN_PROGRESS\" then \"üîµ\"
         elif .state == \"QUEUED\" then \"üßµ\"
         elif .state == \"FAILURE\" then \"üö®\"
         elif .state == \"CANCELED\" then \"‚úñÔ∏è\"
         else \"‚ùì\" end) as \$emoji |
        \"\\(\$emoji) \\(.name)\" +
        (if .state == \"FAILURE\" or .state == \"IN_PROGRESS\" then \"\\n\\(.link)\" else \"\" end)"
}

render_pr_summary() {
    local pr_number="${1}"
    local pr_title="${2}"
    local pr_labels="${3}"
    local pr_url="${4}"
    local checks_json="${5}"

    # Print PR number and title (first line)
    echo "#${pr_number} ${pr_title}"

    # Print PR labels (second line, only if labels exist)
    if [ -n "${pr_labels}" ]; then
        echo "Labels: ${pr_labels}"
    fi

    # Print PR URL (next line)
    echo "${pr_url}"

    # Print "Checks:" followed by emoji statuses (next line)
    echo -n "Checks: "
    jq -r \
    "sort_by(
        if .state == \"FAILURE\" then 1
        elif .state == \"CANCELED\" then 2
        elif .state == \"IN_PROGRESS\" then 3
        elif .state == \"QUEUED\" then 4
        elif .state == \"SUCCESS\" then 6
        else 5 end
    ) | .[] |
        (if .state == \"SUCCESS\" then \"‚úÖ\"
         elif .state == \"IN_PROGRESS\" then \"üîµ\"
         elif .state == \"QUEUED\" then \"üßµ\"
         elif .state == \"FAILURE\" then \"üö®\"
         elif .state == \"CANCELED\" then \"‚úñÔ∏è\"
         else \"‚ùì\" end)" <<<"${checks_json}" | tr '\n' ' '
    echo ""
}

add_pr_label() {
    local repo="${1}"
    local pr_number="${2}"
    local label="${3}"

    if ! quiet gh_api_post "/repos/${repo}/issues/${pr_number}/labels" \
        -H "Content-Type: application/json" \
        -d "{\"labels\":[\"${label}\"]}"
    then
        echo "    Warning: Failed to add label '${label}' to PR #${pr_number}" >&2
        return 1
    fi

    return 0
}

send_desktop_notification() {
    local failed_count="${1}"
    local pr_title="${2}"

    # Determine urgency based on failure count
    local urgency="normal"
    if [ "${failed_count}" -gt 5 ]; then
        urgency="critical"
    fi

    # Send notification
    "${NOTIFY}" \
        --urgency="${urgency}" \
        --app-name="pr-babysitter" \
        --icon="dialog-error" \
        "PR Check Failures" \
        "${failed_count} check(s) failed for:\n${pr_title}"
}

send_success_notification() {
    local pr_title="${1}"

    # Send notification
    "${NOTIFY}" \
        --urgency="normal" \
        --app-name="pr-babysitter" \
        --icon="dialog-information" \
        "PR Checks Passed" \
        "All checks passed successfully for:\n${pr_title}"
}

rerun_github_action() {
    local service="${SERVICE:-github}"

    # Only allow re-runs for GitHub
    if [ "${service}" != "github" ]; then
        echo ""
        echo "Note: Check re-run functionality is only available for GitHub."
        echo "Gitea/Forgejo services do not support automatic check re-runs via API."
        return 0
    fi

    # Determine re-run mode
    rerun_action="${RERUN_MODE}"
    if [ "${RERUN_MODE}" = "ask" ]; then
        echo ""
        echo "Re-run options:"
        echo "  1) Re-run individual check runs (default)"
        echo "  2) Re-run entire workflow runs (all jobs)"
        echo "  3) Re-run only failed jobs in workflows"
        echo "  4) Add a label to re-run checks"
        echo "  n) Skip re-run"
        echo ""
        read -p "Select option (1-3, n): " -n 1 -r
        echo ""

        case ${REPLY} in
            1|"")
                rerun_action="check"
                ;;
            2)
                rerun_action="workflow"
                ;;
            3)
                rerun_action="failed-jobs"
                ;;
            4)
                rerun_action="label"
                ;;
            [Nn])
                rerun_action="skip"
                ;;
            *)
                echo "Invalid option. Skipping re-run."
                rerun_action="skip"
                ;;
        esac
    fi

    # Execute the selected re-run action
    case ${rerun_action} in
        check)
            echo ""
            echo "Re-running individual check runs..."
            # Get all failed checks with their IDs and names
            jq -r "[.[] | select(${FAILED_CHECK_FILTER})] | .[] | \"\(.id)|\(.name)\"" <<<"${CHECKS_JSON}" | \
            while IFS='|' read -r check_id check_name; do
                echo "  Requesting re-run for: ${check_name}"
                rerun_check "${REPO}" "${check_id}" || true
            done
            ;;
        workflow)
            echo ""
            echo "Re-running entire workflow runs..."
            # Get unique workflow run IDs from failed GitHub Actions checks
            FAILED_GA_CHECKS=$(jq -r "[.[] | select(${FAILED_CHECK_FILTER}) | select(.isGitHubActions == true)] | unique_by(.checkSuiteId)" <<<"${CHECKS_JSON}")

            # shellcheck disable=SC2312
            if [ "$(jq 'length' <<<"${FAILED_GA_CHECKS}")" -eq 0 ]; then
                echo "  No GitHub Actions workflows to re-run"
            else
                # shellcheck disable=SC2034
                jq -r '.[] | "\(.id)|\(.name)|\(.appName)"' <<<"${FAILED_GA_CHECKS}" | \
                while IFS='|' read -r check_id check_name app_name; do
                    echo "  Finding workflow run for: ${check_name}"
                    run_id=$(get_workflow_run_id_from_check "${REPO}" "${check_id}")

                    if [ -n "${run_id}" ]; then
                        echo "    Re-running workflow run ${run_id}..."
                        rerun_workflow_run "${REPO}" "${run_id}" || true
                    else
                        echo "    Warning: Could not find workflow run ID"
                    fi
                done
            fi
            ;;
        failed-jobs)
            echo ""
            echo "Re-running only failed jobs in workflows..."
            # Get unique workflow run IDs from failed GitHub Actions checks
            FAILED_GA_CHECKS=$(jq -r "[.[] | select(${FAILED_CHECK_FILTER}) | select(.isGitHubActions == true)] | unique_by(.checkSuiteId)" <<<"${CHECKS_JSON}")

            # shellcheck disable=SC2312
            if [ "$(jq 'length' <<<"${FAILED_GA_CHECKS}")" -eq 0 ]; then
                echo "  No GitHub Actions workflows to re-run"
            else
                # shellcheck disable=SC2034
                jq -r '.[] | "\(.id)|\(.name)|\(.appName)"' <<<"${FAILED_GA_CHECKS}" | \
                while IFS='|' read -r check_id check_name app_name; do
                    echo "  Finding workflow run for: ${check_name}"
                    run_id=$(get_workflow_run_id_from_check "${REPO}" "${check_id}")

                    if [ -n "${run_id}" ]; then
                        echo "    Re-running failed jobs in workflow run ${run_id}..."
                        rerun_failed_jobs "${REPO}" "${run_id}" || true
                    else
                        echo "    Warning: Could not find workflow run ID"
                    fi
                done
            fi
            ;;
        label)
            echo ""
            IFS= read -p "Label name: " -r LABEL_NAME
            echo "Adding label '${LABEL_NAME}' to PR #${PR_NUMBER}..."
            if add_pr_label "${REPO}" "${PR_NUMBER}" "${LABEL_NAME}"; then
                echo "  Successfully added label '${LABEL_NAME}'"
            else
                echo "  Failed to add label"
            fi
            ;;
        skip)
            echo "Skipping re-run."
            return 0
            ;;
        *)
            echo "Unknown re-run mode: ${rerun_action}. Skipping."
            return 1
            ;;
    esac

    echo "Done."
}

monitor_multiple_prs() {
    local repo="${1}"
    shift
    local pr_numbers=("$@")

    echo "Retrieving data for ${#pr_numbers[@]} PRs in ${repo}..."
    echo ""

    # Declare associative arrays to store PR data
    declare -A pr_titles
    declare -A pr_labels
    declare -A pr_head_shas
    declare -A pr_checks

    while true; do
        # First loop: Fetch all PR data
        for pr_number in "${pr_numbers[@]}"; do
            # Get PR title
            pr_titles["${pr_number}"]=$(get_pr_title "${pr_number}" "${repo}" 2>/dev/null || echo "")

            if [ -z "${pr_titles[${pr_number}]}" ]; then
                pr_labels["${pr_number}"]=""
                pr_head_shas["${pr_number}"]=""
                pr_checks["${pr_number}"]=""
                continue
            fi

            # Get PR labels
            pr_labels["${pr_number}"]=$(get_pr_labels "${pr_number}" "${repo}" 2>/dev/null || echo "")

            # Get latest commit SHA
            pr_head_shas["${pr_number}"]=$(get_pr_head_sha "${pr_number}" "${repo}" 2>/dev/null || echo "")

            if [ -z "${pr_head_shas[${pr_number}]}" ]; then
                pr_checks["${pr_number}"]=""
                continue
            fi

            # Get check status
            pr_checks["${pr_number}"]=$(get_check_runs "${repo}" "${pr_head_shas[${pr_number}]}" 2>/dev/null || echo "")
        done

        # Clear screen for clean output
        clear

        echo "=================================================="
        echo "Multi-PR Monitor - ${repo}"
        echo "=================================================="
        echo ""

        # Second loop: Display all PR statuses
        for pr_number in "${pr_numbers[@]}"; do
            # Check if we have PR title
            if [ -z "${pr_titles[${pr_number}]}" ]; then
                echo "#${pr_number} (Error: Could not retrieve PR)"
                echo ""
                continue
            fi

            # Check if we have HEAD SHA
            if [ -z "${pr_head_shas[${pr_number}]}" ]; then
                local pr_url
                pr_url=$(get_pr_url "${repo}" "${pr_number}")
                echo "#${pr_number} ${pr_titles[${pr_number}]}"
                echo "${pr_url}"
                echo "Checks: ‚ùì (Error: Could not retrieve checks)"
                echo ""
                continue
            fi

            # Check if we have checks data
            if [ -z "${pr_checks[${pr_number}]}" ] || [ "${pr_checks[${pr_number}]}" = "null" ]; then
                local pr_url
                pr_url=$(get_pr_url "${repo}" "${pr_number}")
                echo "#${pr_number} ${pr_titles[${pr_number}]}"
                echo "${pr_url}"
                echo "Checks: ‚ùì (No checks found)"
                echo ""
                continue
            fi

            # Render PR summary
            local pr_url
            pr_url=$(get_pr_url "${repo}" "${pr_number}")
            render_pr_summary "${pr_number}" "${pr_titles[${pr_number}]}" "${pr_labels[${pr_number}]}" "${pr_url}" "${pr_checks[${pr_number}]}"
            echo ""
        done

        echo "-----------------------------------"
        # shellcheck disable=SC2312
        echo "Last updated: $(date '+%Y-%m-%d %H:%M:%S')"

        # Check overall status across all PRs
        local has_restartable_failures=false
        local all_checks_successful=true

        for pr_number in "${pr_numbers[@]}"; do
            if [ -n "${pr_checks[${pr_number}]}" ] && [ "${pr_checks[${pr_number}]}" != "null" ]; then
                local failed_count
                local active_count
                local success_count
                local total_count
                failed_count=$(jq "[.[] | select(.state == \"FAILURE\" or .state == \"CANCELED\")] | length" <<<"${pr_checks[${pr_number}]}")
                active_count=$(jq "[.[] | select(.state == \"IN_PROGRESS\" or .state == \"QUEUED\")] | length" <<<"${pr_checks[${pr_number}]}")
                success_count=$(jq "[.[] | select(.state == \"SUCCESS\")] | length" <<<"${pr_checks[${pr_number}]}")
                total_count=$(jq "length" <<<"${pr_checks[${pr_number}]}")

                # Check if this PR has failed checks with no active checks
                if [ "${failed_count}" -gt 0 ] && [ "${active_count}" -eq 0 ]; then
                    has_restartable_failures=true
                fi

                # Check if this PR has all checks successful
                if [ "${total_count}" -eq 0 ] || [ "${success_count}" -ne "${total_count}" ]; then
                    all_checks_successful=false
                fi
            else
                # No checks or error retrieving checks
                all_checks_successful=false
            fi
        done

        # If all checks across all PRs are successful, exit monitoring
        if [ "${all_checks_successful}" = true ]; then
            echo ""
            echo "‚úÖ All checks passed successfully for all monitored PRs!"
            echo "Monitoring stopped."
            echo "-----------------------------------"
            exit 0
        fi

        if [ "${has_restartable_failures}" = true ] && [ "${SERVICE}" = "github" ]; then
            echo "Press 'R' to restart failed checks, or wait for auto-refresh..."
            echo "Press Ctrl+C to stop monitoring"
            echo "-----------------------------------"

            # Wait for input with timeout
            if read -t "${WAIT_TIME}" -n 1 -s -r key; then
                if [[ "${key}" == "R" ]] || [[ "${key}" == "r" ]]; then
                    # Clear screen before showing restart options
                    clear

                    echo "=================================================="
                    echo "Restart Failed Checks"
                    echo "=================================================="

                    # Re-run failed checks for each PR that has failures
                    for pr_number in "${pr_numbers[@]}"; do
                        if [ -n "${pr_checks[${pr_number}]}" ] && [ "${pr_checks[${pr_number}]}" != "null" ]; then
                            local failed_count
                            local active_count
                            failed_count=$(jq "[.[] | select(.state == \"FAILURE\" or .state == \"CANCELED\")] | length" <<<"${pr_checks[${pr_number}]}")
                            active_count=$(jq "[.[] | select(.state == \"IN_PROGRESS\" or .state == \"QUEUED\")] | length" <<<"${pr_checks[${pr_number}]}")

                            if [ "${failed_count}" -gt 0 ] && [ "${active_count}" -eq 0 ]; then
                                echo ""
                                echo "=================================================="
                                # Display PR title (folded to 72 characters)
                                fold -w 72 -s <<<"PR #${pr_number} - ${pr_titles[${pr_number}]}"
                                # Display labels if any
                                if [ -n "${pr_labels[${pr_number}]}" ]; then
                                    echo "Labels: ${pr_labels[${pr_number}]}"
                                fi
                                local pr_url
                                pr_url=$(get_pr_url "${repo}" "${pr_number}")
                                echo "${pr_url}"
                                echo "=================================================="
                                echo ""

                                # Display detailed check status
                                render_checks <<<"${pr_checks[${pr_number}]}"

                                echo ""
                                echo "-----------------------------------"

                                # Ask user how to restart this PR's checks
                                echo ""
                                echo "Re-run options for PR #${pr_number}:"
                                echo "  1) Re-run individual check runs (default)"
                                echo "  2) Re-run entire workflow runs (all jobs)"
                                echo "  3) Re-run only failed jobs in workflows"
                                echo "  4) Add a label to re-run checks"
                                echo "  s) Skip this PR"
                                echo ""
                                read -p "Select option (1-4, s): " -n 1 -r
                                echo ""

                                case ${REPLY} in
                                    1|"")
                                        echo ""
                                        echo "Re-running individual check runs..."
                                        jq -r '[.[] | select(.state == "FAILURE" or .state == "CANCELED")] | .[] | "\(.id)|\(.name)"' <<<"${pr_checks[${pr_number}]}" | \
                                        while IFS='|' read -r check_id check_name; do
                                            echo "  Requesting re-run for: ${check_name}"
                                            rerun_check "${repo}" "${check_id}" || true
                                        done
                                        echo "Done."
                                        ;;
                                    2)
                                        echo ""
                                        echo "Re-running entire workflow runs..."
                                        FAILED_GA_CHECKS=$(jq -r '[.[] | select(.state == "FAILURE" or .state == "CANCELED") | select(.isGitHubActions == true)] | unique_by(.checkSuiteId)' <<<"${pr_checks[${pr_number}]}")

                                        # shellcheck disable=SC2312
                                        if [ "$(jq 'length' <<<"${FAILED_GA_CHECKS}")" -eq 0 ]; then
                                            echo "  No GitHub Actions workflows to re-run"
                                        else
                                            # shellcheck disable=SC2034
                                            jq -r '.[] | "\(.id)|\(.name)|\(.appName)"' <<<"${FAILED_GA_CHECKS}" | \
                                            while IFS='|' read -r check_id check_name app_name; do
                                                echo "  Finding workflow run for: ${check_name}"
                                                run_id=$(get_workflow_run_id_from_check "${repo}" "${check_id}")

                                                if [ -n "${run_id}" ]; then
                                                    echo "    Re-running workflow run ${run_id}..."
                                                    rerun_workflow_run "${repo}" "${run_id}" || true
                                                else
                                                    echo "    Warning: Could not find workflow run ID"
                                                fi
                                            done
                                        fi
                                        echo "Done."
                                        ;;
                                    3)
                                        echo ""
                                        echo "Re-running only failed jobs in workflows..."
                                        FAILED_GA_CHECKS=$(jq -r '[.[] | select(.state == "FAILURE" or .state == "CANCELED") | select(.isGitHubActions == true)] | unique_by(.checkSuiteId)' <<<"${pr_checks[${pr_number}]}")

                                        # shellcheck disable=SC2312
                                        if [ "$(jq 'length' <<<"${FAILED_GA_CHECKS}")" -eq 0 ]; then
                                            echo "  No GitHub Actions workflows to re-run"
                                        else
                                            # shellcheck disable=SC2034
                                            jq -r '.[] | "\(.id)|\(.name)|\(.appName)"' <<<"${FAILED_GA_CHECKS}" | \
                                            while IFS='|' read -r check_id check_name app_name; do
                                                echo "  Finding workflow run for: ${check_name}"
                                                run_id=$(get_workflow_run_id_from_check "${repo}" "${check_id}")

                                                if [ -n "${run_id}" ]; then
                                                    echo "    Re-running failed jobs in workflow run ${run_id}..."
                                                    rerun_failed_jobs "${repo}" "${run_id}" || true
                                                else
                                                    echo "    Warning: Could not find workflow run ID"
                                                fi
                                            done
                                        fi
                                        echo "Done."
                                        ;;
                                    4)
                                        echo ""
                                        IFS= read -p "Label name: " -r LABEL_NAME
                                        echo "Adding label '${LABEL_NAME}' to PR #${pr_number}..."
                                        if add_pr_label "${repo}" "${pr_number}" "${LABEL_NAME}"; then
                                            echo "  Successfully added label '${LABEL_NAME}'"
                                        else
                                            echo "  Failed to add label"
                                        fi
                                        ;;
                                    [Ss])
                                        echo "Skipping PR #${pr_number}."
                                        ;;
                                    *)
                                        echo "Invalid option. Skipping PR #${pr_number}."
                                        ;;
                                esac
                            fi
                        fi
                    done

                    echo ""
                    echo "Re-run requests completed."
                    echo ""
                    echo "Retrieving data for ${#pr_numbers[@]} PRs in ${repo}..."
                    echo ""
                fi
            fi
        elif [ "${has_restartable_failures}" = true ]; then
            # Failures exist but service doesn't support re-runs
            echo "Note: Check re-run functionality is only available for GitHub."
            echo "Press Ctrl+C to stop monitoring"
            echo "-----------------------------------"

            # Wait before next check
            sleep "${WAIT_TIME}"
        else
            echo "Press Ctrl+C to stop monitoring"
            echo "-----------------------------------"

            # Wait before next check
            sleep "${WAIT_TIME}"
        fi
    done
}

check_dependencies() {
    MISSING=0

    # Check if curl is installed
    if ! quiet command -v curl; then
        echo "Error: curl is not installed."
        MISSING=1
    fi

    # Check if jq is installed
    if ! quiet command -v jq; then
        echo "Error: jq is not installed."
        MISSING=1
    fi

    # Check if fold is installed
    if ! quiet command -v fold; then
        echo "Error: fold is not installed."
        MISSING=1
    fi

    # Check if git is installed
    if ! quiet command -v git; then
        echo "Error: git is not installed."
        MISSING=1
    fi

    # Check if notify-send is available
    if quiet command -v notify-send; then
        NOTIFY="notify-send"
    fi

    [[ "${MISSING}" -ne 0 ]] && exit 1 || return 0
}

# Check dependencies
check_dependencies

# Default values
WAIT_TIME="${DEFAULT_WAIT_TIME}"
FAILED_ONLY=false
SERVICE="github"  # Default service (github, codeberg, or custom URL)
RERUN_MODE="ask"  # ask, check, workflow, failed-jobs, label
LABEL_NAME=""     # Label name to add to PR when using label mode
CHECK_ID=""       # Direct check run ID to re-run
WORKFLOW_ID=""    # Direct workflow run ID to re-run
MULTI_PR_MODE=false  # Multi-PR monitoring mode
MULTI_PR_REPO=""     # Repository for multi-PR mode

NOTIFY="${NOTIFY:-":"}"

# Parse options
while getopts "fw:s:r:c:W:m:vVh" opt; do
    case ${opt} in
        f)
            FAILED_ONLY=true
            ;;
        w)
            WAIT_TIME="${OPTARG}"
            ;;
        s)
            SERVICE="${OPTARG}"
            ;;
        r)
            # Validate rerun mode
            case "${OPTARG}" in
                check|workflow|failed-jobs|ask)
                    RERUN_MODE="${OPTARG}"
                    ;;
                label:*)
                    RERUN_MODE="label"
                    LABEL_NAME="${OPTARG#label:}"
                    if [[ -z "${LABEL_NAME}" ]]
                    then
                        echo "Error: Label name must not be empty."
                        exit 1
                    fi
                    ;;
                *)
                    echo "Error: Invalid rerun mode. Use: check, workflow, failed-jobs, label:NAME, or ask"
                    exit 1
                    ;;
            esac
            ;;
        c)
            # Validate check run ID is numeric
            if ! [[ "${OPTARG}" =~ ^[0-9]+$ ]]; then
                echo "Error: CHECK_ID must be a positive integer"
                exit 1
            fi
            CHECK_ID="${OPTARG}"
            ;;
        W)
            # Validate workflow run ID is numeric
            if ! [[ "${OPTARG}" =~ ^[0-9]+$ ]]; then
                echo "Error: WORKFLOW_ID must be a positive integer"
                exit 1
            fi
            WORKFLOW_ID="${OPTARG}"
            ;;
        m)
            MULTI_PR_MODE=true
            MULTI_PR_REPO="${OPTARG}"
            # Validate REPO format (owner/repo)
            if ! [[ "${MULTI_PR_REPO}" =~ ^[a-zA-Z0-9_.-]+/[a-zA-Z0-9_.-]+$ ]]; then
                echo "Error: REPO must be in owner/repo format"
                exit 1
            fi
            ;;
        v)
            VERBOSE="YES"
            ;;
        V)
            echo "pr-babysitter version ${VERSION}"
            exit 0
            ;;
        h)
            usage
            ;;
        *)
            echo "Error: invalid option: ${opt}"
            exit 1
            ;;
    esac
done
shift $((OPTIND - 1))

# Parse arguments based on mode
if [ "${MULTI_PR_MODE}" = true ]; then
    # Multi-PR monitoring mode: PR numbers are positional arguments
    if [ $# -lt 1 ]; then
        echo "Error: At least one PR_NUMBER required for multi-PR mode"
        usage
    fi

    # Collect all PR numbers from positional arguments
    MULTI_PR_NUMBERS=()
    for arg in "$@"; do
        # Validate each PR_NUMBER is numeric
        if ! [[ "${arg}" =~ ^[0-9]+$ ]]; then
            echo "Error: PR_NUMBER must be a positive integer: ${arg}"
            exit 1
        fi
        MULTI_PR_NUMBERS+=("${arg}")
    done

    # Call multi-PR monitoring function and exit
    monitor_multiple_prs "${MULTI_PR_REPO}" "${MULTI_PR_NUMBERS[@]}"
    exit 0
elif [ -n "${CHECK_ID}" ] || [ -n "${WORKFLOW_ID}" ]; then
    # Direct re-run mode: only REPO is required
    REPO="${1:-}"
    PR_NUMBER=""

    if [ -z "${REPO}" ]; then
        # Try to get repo from git
        REPO=$(get_repo_from_git 2>/dev/null || echo "")
        if [ -z "${REPO}" ]; then
            echo "Error: REPO required for direct re-run. Specify as argument or run from git repository."
            exit 1
        fi
    fi
elif [ "${RERUN_MODE}" == "label" ]; then
    PR_NUMBER="${1}"
    REPO="${2:-}"
    if [ -z "${REPO}" ]; then
        # Try to get repo from git
        REPO=$(get_repo_from_git 2>/dev/null || echo "")
        if [ -z "${REPO}" ]; then
            echo "Error: REPO required for direct re-run. Specify as argument or run from git repository."
            exit 1
        fi
    fi
else
    # Normal PR monitoring mode
    PR_NUMBER="${1}"
    REPO="${2:-}"

    if [ -z "${PR_NUMBER}" ]; then
        usage
    fi

    # Validate PR_NUMBER is numeric
    if ! [[ "${PR_NUMBER}" =~ ^[0-9]+$ ]]; then
        echo "Error: PR_NUMBER must be a positive integer"
        exit 1
    fi

    # If REPO is not provided, try to get it from the current git repository
    if [ -z "${REPO}" ]; then
        REPO=$(get_repo_from_git 2>/dev/null || echo "")
        if [ -z "${REPO}" ]; then
            echo "Error: Could not determine repository. Please specify REPO argument or run from within a git repository."
            exit 1
        fi
    fi
fi

# Validate REPO format (owner/repo)
if ! [[ "${REPO}" =~ ^[a-zA-Z0-9_.-]+/[a-zA-Z0-9_.-]+$ ]]; then
    echo "Error: REPO must be in owner/repo format"
    exit 1
fi

# Check if re-run operations are attempted with non-GitHub services
if [ "${SERVICE}" != "github" ]; then
    if [ -n "${CHECK_ID}" ] || [ -n "${WORKFLOW_ID}" ] || [ "${RERUN_MODE}" == "label" ]; then
        echo "Error: Check re-run operations are only supported for GitHub service." >&2
        echo "Gitea/Forgejo services do not support automatic check re-runs via API." >&2
        exit 1
    fi
    if [ "${RERUN_MODE}" != "ask" ]; then
        echo "Error: Re-run mode '${RERUN_MODE}' is not supported for ${SERVICE}." >&2
        echo "Gitea/Forgejo services do not support automatic check re-runs via API." >&2
        echo "Use '-r ask' or omit the -r option for monitoring mode only." >&2
        exit 1
    fi
fi

# Handle direct re-run mode
if [ -n "${CHECK_ID}" ]; then
    echo "Re-running check run ${CHECK_ID} in ${REPO}..."
    if rerun_check "${REPO}" "${CHECK_ID}"; then
        echo "‚úÖ Successfully requested re-run for check ${CHECK_ID}"
    else
        echo "‚ùå Failed to re-run check ${CHECK_ID}"
        exit 1
    fi
    exit 0
elif [ -n "${WORKFLOW_ID}" ]; then
    echo "Re-running workflow run ${WORKFLOW_ID} in ${REPO}..."
    if rerun_workflow_run "${REPO}" "${WORKFLOW_ID}"; then
        echo "‚úÖ Successfully requested re-run for workflow ${WORKFLOW_ID}"
    else
        echo "‚ùå Failed to re-run workflow ${WORKFLOW_ID}"
        exit 1
    fi
    exit 0
elif [ "${RERUN_MODE}" == "label" ]; then
    echo "Re-runing checks by adding label '${LABEL_NAME}' to '${REPO}'..."
    if add_pr_label "${REPO}" "${PR_NUMBER}" "${LABEL_NAME}"; then
        echo "‚úÖ Successfully add label to ${REPO}"
    else
        echo "‚ùå Failed to add label to ${REPO}"
        exit 1
    fi
    exit 0
fi

# Get the latest commit SHA for the PR
PR_HEAD_SHA=$(get_pr_head_sha "${PR_NUMBER}" "${REPO}")
if [ -z "${PR_HEAD_SHA}" ]; then
    echo "Error: Could not get HEAD SHA for PR #${PR_NUMBER}"
    exit 1
fi

# Get the PR title for notifications
PR_TITLE=$(get_pr_title "${PR_NUMBER}" "${REPO}")
if [ -z "${PR_TITLE}" ]; then
    PR_TITLE="PR #${PR_NUMBER}"
fi

# Get the PR labels
PR_LABELS=$(get_pr_labels "${PR_NUMBER}" "${REPO}")

# ANSI color codes
# shellcheck disable=SC2034
WHITE="\033[1;37m"
# shellcheck disable=SC2034
CYAN="\033[36m"
# shellcheck disable=SC2034
RESET="\033[0m"

# If failed-only mode, show failed checks and exit
if [ "${FAILED_ONLY}" = true ]; then
    CHECKS_JSON=$(get_check_runs "${REPO}" "${PR_HEAD_SHA}")
    FAILED_CHECKS=$(jq '[.[] | select(.state != "SUCCESS" and .state != "IN_PROGRESS" and .state != "QUEUED")] | length' <<<"${CHECKS_JSON}")

    if [ "${FAILED_CHECKS}" -eq 0 ]; then
        echo "No failed checks found for PR #${PR_NUMBER}"
        exit 0
    fi

    echo "========================================"
    echo "Failed Checks for PR #${PR_NUMBER}"
    echo "========================================"
    echo ""
    # Display PR title
    echo "PR #${PR_NUMBER} - ${PR_TITLE}"
    # Display labels if any
    if [ -n "${PR_LABELS}" ]; then
        echo "Labels: ${PR_LABELS}"
    fi
    PR_URL=$(get_pr_url "${REPO}" "${PR_NUMBER}")
    echo "${PR_URL}"
    echo ""
    render_checks '.state != "SUCCESS" and .state != "IN_PROGRESS" and .state != "QUEUED"' <<<"${CHECKS_JSON}"
    send_desktop_notification "${FAILED_CHECKS}" "${PR_TITLE}"
    exit 0
fi

# Monitor checks
echo "Monitoring checks for PR #${PR_NUMBER}..."
echo ""

# Common filters
FAILED_CHECK_FILTER=".state != \"SUCCESS\" and .state != \"IN_PROGRESS\" and .state != \"QUEUED\""
RUNNING_CHECK_FILTER=".state == \"IN_PROGRESS\" or .state == \"QUEUED\""

# Track previous failure count to avoid notification spam
PREV_FAILED_CHECKS=0

while true; do
    # Clear screen for clean output
    clear

    echo "=================================================="
    # Display PR title (folded to 72 characters)
    fold -w 72 -s <<<"PR #${PR_NUMBER} - ${PR_TITLE}"
    # Display labels if any
    if [ -n "${PR_LABELS}" ]; then
        echo "Labels: ${PR_LABELS}"
    fi
    PR_URL=$(get_pr_url "${REPO}" "${PR_NUMBER}")
    echo "${PR_URL}"
    echo "=================================================="
    echo ""

    # Get latest commit SHA (in case there are new commits)
    PR_HEAD_SHA=$(get_pr_head_sha "${PR_NUMBER}" "${REPO}")

    # Get check status
    CHECKS_JSON=$(get_check_runs "${REPO}" "${PR_HEAD_SHA}")

    # Format and display output
    render_checks <<<"${CHECKS_JSON}"

    echo ""
    echo "-----------------------------------"
    # shellcheck disable=SC2312
    echo "Last updated: $(date '+%Y-%m-%d %H:%M:%S')"

    # Check for failed checks and send notification if count changed
    FAILED_CHECKS=$(jq "[.[] | select(${FAILED_CHECK_FILTER})] | length" <<<"${CHECKS_JSON}")
    if [ "${FAILED_CHECKS}" -gt 0 ] && [ "${FAILED_CHECKS}" -ne "${PREV_FAILED_CHECKS}" ]; then
        send_desktop_notification "${FAILED_CHECKS}" "${PR_TITLE}"
        PREV_FAILED_CHECKS="${FAILED_CHECKS}"
    fi

    # Check if there are any IN_PROGRESS or QUEUED checks
    ACTIVE_CHECKS=$(jq "[.[] | select(${RUNNING_CHECK_FILTER})] | length" <<<"${CHECKS_JSON}")

    if [ "${ACTIVE_CHECKS}" -eq 0 ]; then
        echo "All checks completed. Monitoring stopped."
        echo "-----------------------------------"

        if [ "${FAILED_CHECKS}" -gt 0 ]; then
            echo ""
            echo "There are ${FAILED_CHECKS} failed check(s)."
            if [ "${SERVICE}" = "github" ]; then
                rerun_github_action
            else
                echo ""
                echo "Note: Check re-run functionality is only available for GitHub."
                echo "Gitea/Forgejo services do not support automatic check re-runs via API."
                break
            fi
        else
            echo ""
            echo "‚úÖ All checks passed successfully!"
            send_success_notification "${PR_TITLE}"
            # Exit monitoring loop
            break
        fi
    fi

    echo "Press Ctrl+C to stop monitoring"
    echo "-----------------------------------"

    # Wait before next check
    sleep "${WAIT_TIME}"
done
